---
title: 동적 계획법(Dynamic Programming) 알고리즘
date: '2024-11-12'
tags: ['Algorithm']
draft: false
summary:
---

코딩테스트 문제로 '피보나치 수열'을 풀었는데 다음과 같이 푸니 정확성을 통과하지 못했다. (시간 초과)

```
const f = (n) => {
  return n <= 1 ? n : f(n - 1) + f(n - 2);
};
```

피보나치 수열 점화식은 `F(n) = F(n-1) + F(n-2)`인데 만약 `n = 5`라면 다음과 같은 트리 구조를 만들 수 있다.

<img
  src="https://github.com/user-attachments/assets/89077308-f388-4a27-b522-536941bb465d"
  width="400"
/>

이렇게 볼 경우 f(5)를 구하기 위해 f(3)등의 트리에서 많은 중복이 발생하는 것을 확인할 수 있다.
동일한 트리를 개별적으로 재귀를 수행하는 것이 아닌 **해당 시점에서 이미 계산한 값이 있다면
해당 값을 바로 사용하는 기법이 Memoization 기법**이다.
즉, **Memoization 기법을 통해 중복 연산을 방지하며 작은 부분 문제로 큰 문제를 해결하며
해를 도출하는 알고리즘 설계 기법을 동적 계획법 (Dynamic Programming**)이라고 한다.

동적 계획법의 구현 방식에는 Top-down 방식과 Bottom-up 방식이 있다.

1. Top-Down : 재귀를 통해 큰 문제를 작은 문제로 나눠 해를 찾는 방법

이 방식은 특정 부분 문제들만 필요한 경우에 효과적이다.

```
function fibo(n) {
  const d = [];
  if (n < 2) return n;
  if (d[n]) return d[n];

  d[n] = fibo(n - 1) + fibo(n - 2);

  return d[n];
}
```

2. Bottom-up : 반복문을 통해 작은 문제부터 차례대로 해를 찾는 방법

이 방식은 순차적으로 문제를 해결할 때 효율적이다.

```
function fibo(n) {
  const d = [];
  d[0] = 0;
  d[1] = 1;

  for (let i = 2; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2];
  }

  return d[n];
}
```

Bottom-up 방식을 통해 피보나치 수열을 계산하면 위에서 중복이 많았던 계산이 다음과 같이 줄어들게 된다.

```
d[0] = 0
d[1] = 1
d[2] = d[1] + d[0] = 1
d[3] = d[2] + d[1] = 1 + 1 = 2
d[4] = d[3] + d[2] = 2 + 1 = 3
d[5] = d[4] + d[3] = 3 + 2 = 5
```

이는 재귀를 통해 값을 다시 계산하는 것이 아닌 배열에 저장되어 있는 값을 가져다 사용하는 것이라
시간 복잡도가 `O(n)`으로 위에서 처음 작성했던 코드보다 효율적으로 계산된다.
